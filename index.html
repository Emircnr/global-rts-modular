<!doctype html>
<html lang="tr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Gate.io MAC Bracket Bot — Tek Dosya</title>
<style>
  :root{
    --bg:#0b0f19; --fg:#e8eef7; --muted:#9fb0c9;
    --panel:#0f162a; --panel2:#121a33; --glass:rgba(255,255,255,.05);
    --border:#1b2a4a; --accent:#60a5fa; --good:#22c55e; --bad:#ef4444; --warn:#f59e0b;
    --radius:16px; --gap:14px; --padY:12px; --padX:14px; --font:16px; --maxW:1180px;
  }
  *{box-sizing:border-box} html,body{height:100%}
  body{margin:0;background:var(--bg);color:var(--fg);font:500 var(--font)/1.5 system-ui,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial}
  .wrap{max-width:var(--maxW);margin:0 auto;padding:24px}
  h1{margin:0 0 10px;font-size:28px;letter-spacing:.2px}
  .sub{color:var(--muted);margin-bottom:22px}
  .grid{display:grid;grid-template-columns:1.2fr .8fr;gap:var(--gap)}
  .card{background:linear-gradient(180deg,var(--panel),var(--panel2));border:1px solid var(--border);border-radius:var(--radius);padding:var(--padY) var(--padX);box-shadow:0 10px 30px rgba(0,0,0,.25)}
  .row{display:grid;grid-template-columns:1fr 1fr;gap:var(--gap)}
  label{display:block;font-size:13px;color:var(--muted);margin:6px 0 6px}
  input,textarea,select{
    width:100%; padding:11px 12px; border-radius:12px; border:1px solid var(--border);
    background:rgba(255,255,255,.03); color:var(--fg); outline:none
  }
  input:focus,textarea:focus,select:focus{border-color:var(--accent); box-shadow:0 0 0 3px rgba(96,165,250,.15)}
  .btns{display:flex;gap:10px;flex-wrap:wrap;margin-top:10px}
  button{
    padding:10px 14px;border-radius:12px;border:1px solid var(--border);
    background:var(--glass);color:var(--fg);cursor:pointer;transition:.2s
  }
  button:hover{transform:translateY(-1px);border-color:var(--accent)}
  .primary{background:linear-gradient(180deg,#3b82f6,#2563eb);border-color:#1d4ed8}
  .danger{background:linear-gradient(180deg,#ef4444,#b91c1c);border-color:#7f1d1d}
  .ok{background:linear-gradient(180deg,#22c55e,#15803d);border-color:#166534}
  .muted{opacity:.8}
  .table{width:100%; border-collapse:collapse; font-size:14px}
  .table th, .table td{padding:10px 8px; border-bottom:1px solid var(--border); text-align:left; white-space:nowrap}
  .chip{padding:2px 8px;border-radius:999px; font-size:12px; border:1px solid var(--border); background:rgba(255,255,255,.04)}
  .chip.good{color:#16a34a;border-color:#14532d}
  .chip.bad{color:#ef4444;border-color:#7f1d1d}
  .chip.warn{color:#f59e0b;border-color:#7c4a14}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}
  .log{height:260px; overflow:auto; background:#0b1224; border:1px solid var(--border); border-radius:12px; padding:12px}
  .hint{font-size:12px;color:var(--muted)}
  .sep{height:1px;background:var(--border);margin:12px 0}
</style>
<!-- Firebase compat (tek dosya içinde CDN ile) -->
<script src="https://www.gstatic.com/firebasejs/10.12.5/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.5/firebase-firestore-compat.js"></script>
</head>
<body>
<div class="wrap">
  <h1>Gate.io MAC Bracket Bot</h1>
  <div class="sub">Firestore’daki MAC (upper/mid/lower/close) verilerine göre — <b>saniyede 1</b> güncellenen çift yönlü bracket kurar. Bir taraf dolarsa, diğeri iptal edilir ve <i>iptal edilen band</i> stop olarak takibe alınır.</div>

  <div class="grid">
    <!-- Sol Panel: Ayarlar -->
    <div class="card">
      <h3 style="margin-top:0">Ayarlar</h3>

      <div class="row">
        <div>
          <label>Proxy Base URL</label>
          <input id="proxy" value="http://localhost:8787"/>
          <div class="hint">Örn: http://localhost:8787 (senin proxy)</div>
        </div>
        <div>
          <label>Gate API Key (Header: <span class="mono" id="hdrKey">x-api-key</span>)</label>
          <input id="apiKey" placeholder="Key"/>
        </div>
      </div>

      <div class="row">
        <div>
          <label>Gate API Secret (Header: <span class="mono" id="hdrSec">x-api-secret</span>)</label>
          <input id="apiSecret" placeholder="Secret"/>
        </div>
        <div>
          <label>Header Adları (virgüllü)</label>
          <input id="headerNames" value="x-api-key,x-api-secret"/>
          <div class="hint">Sırasıyla Key, Secret (proxy farklı ad istiyorsa değiştir)</div>
        </div>
      </div>

      <div class="row">
        <div>
          <label>Kaldıraç (L)</label>
          <input id="leverage" type="number" step="1" min="1" value="5"/>
        </div>
        <div>
          <label>Miktar (USDT Notional)</label>
          <input id="notional" type="number" step="1" min="5" value="100"/>
        </div>
      </div>

      <div class="row">
        <div>
          <label>İşlem Sembolleri (virgüllü, örn: BTCUSDT,ETHUSDT)</label>
          <input id="symbols" value="BTCUSDT"/>
        </div>
        <div>
          <label>Firestore Koleksiyonu</label>
          <input id="fsCollection" value="mac_live"/>
          <div class="hint">Her doküman id’si sembol (örn: BTCUSDT) olmalı</div>
        </div>
      </div>

      <div class="row">
        <div>
          <label>Firebase Config (JSON)</label>
          <textarea id="fbCfg" rows="6">{
  "apiKey": "AIzaSyAh6JbnjsZtD-d0g3iSb2maSerPntUP6To",
  "authDomain": "macbot-b7b45.firebaseapp.com",
  "databaseURL": "https://macbot-b7b45-default-rtdb.firebaseio.com",
  "projectId": "macbot-b7b45",
  "storageBucket": "macbot-b7b45.firebasestorage.app",
  "messagingSenderId": "88494187419",
  "appId": "1:88494187419:web:9e0fd1a37e51332203373e",
  "measurementId": "G-SVG851WK7Y"
}</textarea>
        </div>
        <div>
          <label>Mod</label>
          <select id="mode">
            <option value="live">LIVE (Gerçek Emir)</option>
            <option value="dry">DRY-RUN (Emir Gönderme)</option>
          </select>
          <div class="btns">
            <button class="primary" id="saveBtn">Ayarları Kaydet</button>
            <button class="ok" id="initBtn">Firebase Başlat</button>
            <button id="connBtn">Gate Bağlantı Test</button>
          </div>
          <div class="btns">
            <button class="primary" id="startBtn">Botu Başlat</button>
            <button class="danger" id="stopBtn">Durdur</button>
          </div>
        </div>
      </div>

      <div class="sep"></div>
      <div class="hint">Mantık: Kanal içinde -> iki limit (upper long, lower short). Fill olunca karşı tarafı iptal + iptal edilen band’a <b>close</b> stop (price order). Kanal güncellenince stop tetik fiyatı da güncellenir.</div>
    </div>

    <!-- Sağ Panel: Durum & Log -->
    <div class="card">
      <h3 style="margin-top:0">Durum</h3>
      <div style="max-height:260px;overflow:auto;border:1px solid var(--border);border-radius:12px">
        <table class="table mono" id="stateTable">
          <thead>
            <tr>
              <th>Sembol</th><th>Close</th><th>Lower</th><th>Upper</th><th>İçeride?</th><th>Bracket</th><th>Pos</th><th>Stop</th><th>Son</th>
            </tr>
          </thead>
          <tbody id="stateBody"></tbody>
        </table>
      </div>
      <h3>Log</h3>
      <div class="log mono" id="log"></div>
    </div>
  </div>
</div>

<script>
/*** === Yardımcı UI === ***/
const $ = sel => document.querySelector(sel);
const logEl = $('#log');
function log(...args){ const t = new Date().toLocaleTimeString(); logEl.textContent += `[${t}] ` + args.join(' ') + '\n'; logEl.scrollTop = logEl.scrollHeight; }
function setHintIds(){
  $('#hdrKey').textContent = ( $('#headerNames').value.split(',')[0] || 'x-api-key' ).trim();
  $('#hdrSec').textContent = ( $('#headerNames').value.split(',')[1] || 'x-api-secret' ).trim();
}
setHintIds();
$('#headerNames').addEventListener('input', setHintIds);

function saveSettings(){
  const cfg = {
    proxy: $('#proxy').value.trim(),
    apiKey: $('#apiKey').value.trim(),
    apiSecret: $('#apiSecret').value.trim(),
    headerNames: $('#headerNames').value.trim(),
    leverage: +$('#leverage').value,
    notional: +$('#notional').value,
    symbols: $('#symbols').value.trim(),
    fsCollection: $('#fsCollection').value.trim(),
    fbCfg: $('#fbCfg').value.trim(),
    mode: $('#mode').value
  };
  localStorage.setItem('macbot_settings', JSON.stringify(cfg));
  log('Ayarlar kaydedildi.');
}
function loadSettings(){
  const raw = localStorage.getItem('macbot_settings');
  if(!raw) return;
  try{
    const cfg = JSON.parse(raw);
    $('#proxy').value = cfg.proxy || $('#proxy').value;
    $('#apiKey').value = cfg.apiKey || '';
    $('#apiSecret').value = cfg.apiSecret || '';
    $('#headerNames').value = cfg.headerNames || 'x-api-key,x-api-secret';
    $('#leverage').value = cfg.leverage ?? 5;
    $('#notional').value = cfg.notional ?? 100;
    $('#symbols').value = cfg.symbols || 'BTCUSDT';
    $('#fsCollection').value = cfg.fsCollection || 'mac_live';
    $('#fbCfg').value = cfg.fbCfg || $('#fbCfg').value;
    $('#mode').value = cfg.mode || 'live';
    setHintIds();
    log('Ayarlar yüklendi.');
  }catch(e){ log('Ayarlar okunamadı:', e.message); }
}
loadSettings();
$('#saveBtn').onclick = saveSettings;

/*** === Firebase / Firestore === ***/
let fbApp = null, db = null;
let listeners = new Map(); // symbol -> unsubscribe
$('#initBtn').onclick = initFirebase;

function initFirebase(){
  try{
    const cfg = JSON.parse($('#fbCfg').value.trim());
    if(!fbApp){ fbApp = firebase.initializeApp(cfg); db = firebase.firestore(); }
    log('Firebase init OK. ProjectId=', cfg?.projectId);
  }catch(e){ log('Firebase init HATA:', e.message); }
}

/*** === Gate Proxy İstemcisi === ***/
function headersPriv(){
  const [hKey='x-api-key', hSec='x-api-secret'] = $('#headerNames').value.split(',').map(s=>s.trim());
  const hdr = {'Content-Type':'application/json'};
  if($('#apiKey').value) hdr[hKey] = $('#apiKey').value;
  if($('#apiSecret').value) hdr[hSec] = $('#apiSecret').value;
  return hdr;
}
function proxyBase(){ return $('#proxy').value.replace(/\/+$/,''); }
async function gateGET(path, isPriv=false){
  const url = proxyBase() + path;
  const res = await fetch(url, {method:'GET', headers: isPriv ? headersPriv() : {}});
  if(!res.ok) throw new Error(`GET ${path} → ${res.status}`);
  return res.json();
}
async function gatePOST(path, body, isPriv=true){
  const url = proxyBase() + path;
  const res = await fetch(url, {method:'POST', headers: isPriv ? headersPriv() : {'Content-Type':'application/json'}, body: JSON.stringify(body||{})});
  if(!res.ok){
    const txt = await res.text().catch(()=> '');
    throw new Error(`POST ${path} → ${res.status} ${txt}`);
  }
  return res.json();
}
async function gateDELETE(path, isPriv=true){
  const url = proxyBase() + path;
  const res = await fetch(url, {method:'DELETE', headers: isPriv ? headersPriv() : {}});
  if(!res.ok){
    const txt = await res.text().catch(()=> '');
    throw new Error(`DEL ${path} → ${res.status} ${txt}`);
  }
  return res.json().catch(()=> ({}));
}

/*** === Gate.io V4 Yardımcıları (USDT-M Futures) === ***/
// Sözleşme adı: BTCUSDT → BTC_USDT
const toContract = s => s.includes('_') ? s : s.replace(/USDT$/,'_USDT').toUpperCase();

const meta = new Map(); // contract -> {tick, sizeStep, minSize, pricePrec, sizePrec}
async function loadContractMeta(contract){
  if(meta.has(contract)) return meta.get(contract);
  const info = await gateGET(`/api/v4/futures/usdt/contracts/${contract}`, false);
  // Gate alanları (tipik): tick_size, order_size_min, order_size_increment, quanto_multiplier
  const tick = +info.tick_size || 0.1;
  const sizeStep = +info.order_size_increment || 1;
  const minSize = +info.order_size_min || sizeStep;
  const pricePrec = (tick.toString().split('.')[1]||'').length;
  const sizePrec  = (sizeStep.toString().split('.')[1]||'').length;
  const m = {tick, sizeStep, minSize, pricePrec, sizePrec};
  meta.set(contract, m);
  return m;
}
function roundTo(x, step){ return Math.round(x/step)*step; }
function floorTo(x, step){ return Math.floor(x/step)*step; }
function fmt(x, prec=2){ return (+x).toFixed(prec); }

// Leverage ayarla (izole/cross opsiyonel – basit tutuyoruz: kaldıraç set)
async function setLeverage(contract, leverage){
  try{
    await gatePOST(`/api/v4/futures/usdt/positions/${contract}`, {leverage: String(leverage)}, true);
    log(contract, 'kaldıraç set:', leverage, 'OK');
  }catch(e){ log('Leverage HATA', contract, e.message); }
}

// Açık pozisyonu çek (size ile yön)
async function getPosition(contract){
  const arr = await gateGET(`/api/v4/futures/usdt/positions?contract=${encodeURIComponent(contract)}`, true);
  const p = Array.isArray(arr) ? arr.find(x=>x.contract===contract) : arr;
  if(!p) return {size:0};
  return { size: +p.size, entry: +p.entry_price || 0 };
}

// Açık aktif emirleri çek
async function getOpenOrders(contract){
  return gateGET(`/api/v4/futures/usdt/orders?contract=${encodeURIComponent(contract)}&status=open`, true);
}

// Limit emir ver (size >0 long, <0 short)
async function placeLimit(contract, size, price, reduce_only=false, tif='gtc'){
  return gatePOST(`/api/v4/futures/usdt/orders`, {
    contract, size: String(size), price: String(price),
    reduce_only: !!reduce_only, tif
  }, true);
}

// Emri iptal et
async function cancelOrder(contract, order_id){
  return gateDELETE(`/api/v4/futures/usdt/orders/${order_id}`, true);
}

// Koşullu STOP (price order) — tüm pozisyonu kapat
async function placeOrUpdateStop(contract, side, triggerPrice, existingId=null){
  // side: 'long' poz için SELL (rule: <=), 'short' poz için BUY (rule: >=)
  const rule = side==='long' ? "<=" : ">=";
  if(existingId){
    // Gate.io price_orders PATCH yerine yeniden kur/iptal daha sorunsuz
    try{ await gateDELETE(`/api/v4/futures/usdt/price_orders/${existingId}`, true); }catch(_){}
  }
  const body = {
    contract,
    trigger: { price: String(triggerPrice), rule },
    // close:true => mevcut pozisyonu tamamen kapat
    put: { reduce_only: true, close: true }
  };
  const res = await gatePOST(`/api/v4/futures/usdt/price_orders`, body, true);
  return res;
}

/*** === Bot Durumları === ***/
const S = new Map(); // symbol -> state
/* state şeması:
{
  symbol, contract, m:{tick,sizeStep,minSize,pricePrec,sizePrec},
  last: {close,lower,upper,mid,ts},
  bracket: {longId:null, shortId:null, longPx:null, shortPx:null},
  stop: {id:null, side:null, trigPx:null},
  pos: {size:0, entry:0},
  timer: number (setInterval id)
}
*/

function upsertRow(symbol){
  const tb = $('#stateBody');
  let tr = tb.querySelector(`tr[data-sym="${symbol}"]`);
  if(!tr){
    tr = document.createElement('tr');
    tr.dataset.sym = symbol;
    tr.innerHTML = `<td class="mono">${symbol}</td>
      <td data-k="close">-</td>
      <td data-k="lower">-</td>
      <td data-k="upper">-</td>
      <td data-k="inband"><span class="chip">-</span></td>
      <td data-k="bracket"><span class="chip">-</span></td>
      <td data-k="pos"><span class="chip">0</span></td>
      <td data-k="stop"><span class="chip">-</span></td>
      <td data-k="last">-</td>`;
    tb.appendChild(tr);
  }
  return tr;
}
function paint(symbol){
  const st = S.get(symbol); if(!st) return;
  const tr = upsertRow(symbol);
  const set = (k, v)=> tr.querySelector(`[data-k="${k}"]`).innerHTML = v;
  const last = st.last || {};
  const inband = last.close>last.lower && last.close<last.upper;
  set('close', fmt(last.close ?? 0, st.m?.pricePrec||2));
  set('lower', fmt(last.lower ?? 0, st.m?.pricePrec||2));
  set('upper', fmt(last.upper ?? 0, st.m?.pricePrec||2));
  set('inband', `<span class="chip ${inband?'good':'bad'}">${inband?'İÇERİDE':'DIŞARIDA'}</span>`);
  const b = st.bracket || {};
  set('bracket', `<span class="chip">${b.longId?'L#'+b.longId:'-'} | ${b.shortId?'S#'+b.shortId:'-'}</span>`);
  set('pos', `<span class="chip ${st.pos?.size? (st.pos.size>0?'good':'bad'):'warn'}">${st.pos?.size||0}</span>`);
  const sp = st.stop || {};
  set('stop', `<span class="chip">${sp.id? (sp.side==='long'?'SLong@':'SShort@')+fmt(sp.trigPx||0, st.m?.pricePrec||2): '-'}</span>`);
  set('last', `<span class="chip">${new Date().toLocaleTimeString()}</span>`);
}

/*** === Firestore Dinleme === ***/
function startListen(symbol){
  const coll = $('#fsCollection').value.trim();
  const ref = db.collection(coll).doc(symbol);
  if(listeners.has(symbol)) listeners.get(symbol)(); // önceki kes
  const unsub = ref.onSnapshot(doc=>{
    if(!doc.exists){ log(symbol, 'Firestore doküman yok.'); return; }
    const d = doc.data();
    onData(symbol, {
      close: +d.close,
      lower: +d.lower,
      upper: +d.upper,
      mid: +d.mid,
      ts: +d.ts_ms || +d.kline_ts_ms || Date.now()
    });
  }, err=> log('Firestore HATA', symbol, err.message));
  listeners.set(symbol, unsub);
}

/*** === Emir Motoru === ***/
async function onData(symbol, data){
  if(!S.has(symbol)) return;
  const st = S.get(symbol);
  st.last = data;
  paint(symbol); // tabloyu güncelle

  // Her snapshot'ta ağır iş yapmayalım: saniyelik döngüde işlenecek
}

function calcSize(notional, price, sizeStep){
  const raw = notional / Math.max(price, 1e-9);
  return Math.max(sizeStep, floorTo(raw, sizeStep));
}

async function ensureBracket(st){
  const {contract, m, last} = st;
  const inband = last.close>last.lower && last.close<last.upper;
  // Pozisyon var mı?
  const p = await getPosition(contract).catch(e=>{log('Pos HATA', contract, e.message); return {size:0};});
  st.pos = p;

  // Pozisyon varsa bracket kaldır, STOP’u takip et
  if(p.size !== 0){
    // bracket varsa iptal et
    if(st.bracket?.longId){ try{ await cancelOrder(contract, st.bracket.longId); }catch(_){} st.bracket.longId=null; }
    if(st.bracket?.shortId){ try{ await cancelOrder(contract, st.bracket.shortId); }catch(_){} st.bracket.shortId=null; }
    const side = p.size>0 ? 'long' : 'short';
    const trig = side==='long' ? last.lower : last.upper;
    // STOP yoksa kur, varsa güncelle (delete+kur)
    const newStop = await placeOrUpdateStop(contract, side, roundTo(trig, m.tick), st.stop?.id).catch(e=>{ log('STOP HATA', st.symbol, e.message); return null;});
    if(newStop){
      st.stop = { id: newStop.id || newStop.order_id || null, side, trigPx: trig };
      log(st.symbol, 'STOP set ➜', side, '@', fmt(trig, m.pricePrec));
    }
    return; // pozisyondaysan bracket kurma
  }else{
    // Pozisyon yoksa STOP’u temiz kabul et
    st.stop = {id:null, side:null, trigPx:null};
  }

  // Kanal dışındaysa bracket tutma
  if(!inband){
    // varsa aktif bracket iptal
    if(st.bracket?.longId){ try{ await cancelOrder(contract, st.bracket.longId); }catch(_){} st.bracket.longId=null; }
    if(st.bracket?.shortId){ try{ await cancelOrder(contract, st.bracket.shortId); }catch(_){} st.bracket.shortId=null; }
    return;
  }

  // Kanal içindeyiz ve pozisyon yok → iki limit emri (upper long, lower short)
  const L = +$('#leverage').value || 1;
  const USDT = +$('#notional').value || 50;
  const longPx  = roundTo(last.upper, m.tick);
  const shortPx = roundTo(last.lower, m.tick);
  const posNotional = Math.max(5, USDT * L);
  const longSz  = calcSize(posNotional, longPx, m.sizeStep);
  const shortSz = calcSize(posNotional, shortPx, m.sizeStep);

  // Leverage'i bir kere set etmeye çalış (sessiz)
  if(!st.__levSet){ st.__levSet = true; setLeverage(contract, L).catch(_=>{}); }

  // Var olanları aynı fiyata değilse yenile
  const needNewLong  = !st.bracket?.longId  || Math.abs((st.bracket.longPx||0)-longPx)  >= m.tick;
  const needNewShort = !st.bracket?.shortId || Math.abs((st.bracket.shortPx||0)-shortPx) >= m.tick;

  if($('#mode').value==='dry'){
    if(needNewLong)  log(st.symbol, '(DRY) LONG limit @', fmt(longPx,m.pricePrec),'size', longSz);
    if(needNewShort) log(st.symbol, '(DRY) SHORT limit @', fmt(shortPx,m.pricePrec),'size', shortSz);
    st.bracket = { longId: st.bracket?.longId||'dry', shortId: st.bracket?.shortId||'dry', longPx, shortPx };
    return;
  }

  // Long yenile
  if(needNewLong){
    if(st.bracket?.longId){ try{ await cancelOrder(contract, st.bracket.longId); }catch(_){} }
    try{
      const r = await placeLimit(contract, +longSz, longPx, false, 'gtc');
      st.bracket = st.bracket || {};
      st.bracket.longId = r.id || r.order_id || null;
      st.bracket.longPx = longPx;
      log(st.symbol, 'LONG limit kuruldu @', fmt(longPx,m.pricePrec), 'size', longSz, '#', st.bracket.longId);
    }catch(e){ log('LONG place HATA', st.symbol, e.message); }
  }

  // Short yenile
  if(needNewShort){
    if(st.bracket?.shortId){ try{ await cancelOrder(contract, st.bracket.shortId); }catch(_){ } }
    try{
      const r = await placeLimit(contract, -shortSz, shortPx, false, 'gtc');
      st.bracket = st.bracket || {};
      st.bracket.shortId = r.id || r.order_id || null;
      st.bracket.shortPx = shortPx;
      log(st.symbol, 'SHORT limit kuruldu @', fmt(shortPx,m.pricePrec), 'size', shortSz, '#', st.bracket.shortId);
    }catch(e){ log('SHORT place HATA', st.symbol, e.message); }
  }
}

// Dolum algıla: açık emirler değiştiğinde, pozisyon >0 ya da <0 ise diğer bracket’ı iptal et + STOP kur
async function reconcileAfterFills(st){
  const {contract, last, m} = st;
  const p = await getPosition(contract).catch(()=>({size:0}));
  if(!p) return;
  const had = st.pos?.size || 0;
  st.pos = p;

  // yeni pozisyona geçiş
  if(had===0 && p.size!==0){
    const filledSide = p.size>0 ? 'long' : 'short';
    // karşı bracket'ı kapat
    if(filledSide==='long' && st.bracket?.shortId){ try{ await cancelOrder(contract, st.bracket.shortId); }catch(_){ } st.bracket.shortId=null; }
    if(filledSide==='short' && st.bracket?.longId){ try{ await cancelOrder(contract, st.bracket.longId); }catch(_){ } st.bracket.longId=null; }

    // stop’u kur
    const trig = filledSide==='long' ? last.lower : last.upper;
    if($('#mode').value==='dry'){
      st.stop = {id:'dry', side: filledSide, trigPx: trig};
      log(st.symbol, '(DRY) STOP set', filledSide, '@', fmt(trig, m.pricePrec));
    }else{
      const res = await placeOrUpdateStop(contract, filledSide, roundTo(trig, m.tick), null).catch(e=>{ log('STOP place HATA', st.symbol, e.message); return null;});
      if(res){
        st.stop = { id: res.id || res.order_id || null, side: filledSide, trigPx: trig };
        log(st.symbol, 'STOP set', filledSide, '@', fmt(trig, m.pricePrec), '#', st.stop.id);
      }
    }
  }

  // pozisyon sıfırlandıysa stop/bracket temiz akışına dön
  if(had!==0 && p.size===0){
    st.stop = {id:null, side:null, trigPx:null};
    st.bracket = st.bracket || {};
    // bracket yeniden kurulumu ensureBracket içinde yapılacak
  }
}

/*** === Döngü (saniyede 1) === ***/
async function tick(symbol){
  const st = S.get(symbol); if(!st || !st.m || !st.last) return;
  try{
    // 1) Fill’leri uzlaştır
    await reconcileAfterFills(st);
    // 2) Bracket/Stop’u uygun duruma getir
    await ensureBracket(st);
  }catch(e){
    log('tick HATA', symbol, e.message);
  }finally{
    paint(symbol);
  }
}

/*** === Başlat / Durdur === ***/
let running = false;
$('#startBtn').onclick = async ()=>{
  if(!db){ log('Önce Firebase Başlat (Firebase Başlat butonu).'); return; }
  const syms = $('#symbols').value.split(',').map(s=>s.trim().toUpperCase()).filter(Boolean);
  if(syms.length===0){ log('Sembol gir.'); return; }

  running = true;
  for(const sym of syms){
    const contract = toContract(sym);
    S.set(sym, {symbol:sym, contract, last:{}, bracket:{}, stop:{}, pos:{size:0}, __levSet:false});
    upsertRow(sym);
    try{
      const m = await loadContractMeta(contract);
      const st = S.get(sym); st.m = m;
      log(sym, 'meta tick=', m.tick, 'sizeStep=', m.sizeStep);
    }catch(e){
      log('Meta HATA', sym, e.message);
    }
    startListen(sym);
    // saniyelik döngü
    const t = setInterval(()=> tick(sym), 1000);
    S.get(sym).timer = t;
  }
  log('BOT BAŞLADI.');
};

$('#stopBtn').onclick = async ()=>{
  running = false;
  // tüm timer’ları kes, FS dinleyicileri kapat, açık bracket’ları iptal dene
  for(const [sym, st] of S){
    if(st.timer) clearInterval(st.timer);
    if(listeners.get(sym)) { try{ listeners.get(sym)(); }catch(_){} listeners.delete(sym); }
    if($('#mode').value==='live'){
      // bracket iptali
      try{ if(st.bracket?.longId) await cancelOrder(st.contract, st.bracket.longId); }catch(_){}
      try{ if(st.bracket?.shortId) await cancelOrder(st.contract, st.bracket.shortId); }catch(_){}
      // stop iptali (opsiyonel)
      try{ if(st.stop?.id) await gateDELETE(`/api/v4/futures/usdt/price_orders/${st.stop.id}`, true); }catch(_){}
    }
  }
  S.clear();
  $('#stateBody').innerHTML = '';
  log('BOT DURDURULDU.');
};

/*** === Bağlantı Testi === ***/
$('#connBtn').onclick = async ()=>{
  try{
    const ping = await gateGET('/api/v4/spot/currencies', false);
    log('Public OK. Toplam coin:', Array.isArray(ping)?ping.length:'?');
    try{
      const acct = await gateGET('/api/v4/futures/usdt/accounts', true);
      log('Private OK. Hesap özeti çekildi.');
    }catch(e){ log('Private HATA (anahtarları kontrol et):', e.message); }
  }catch(e){
    log('Proxy/Public HATA:', e.message);
  }
};
</script>
</body>
</html>
