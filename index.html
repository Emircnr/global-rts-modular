<!doctype html>
<html lang="tr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Gate.io Futures ‚Üî Spot ‚Äî Maker Arb Bot (Anlƒ±k Fark)</title>
<style>
  :root{
    --bg:#0b0f19; --fg:#e8eef7; --muted:#9fb0c9;
    --panel:#0f162a; --panel2:#101a32; --glass:rgba(255,255,255,.06);
    --border:#1b2a4a; --accent:#60a5fa; --good:#22c55e; --bad:#ef4444;
    --radius:16px; --gap:14px; --padY:12px; --padX:14px; --font:16px; --maxW:1180px;
  }
  body{ margin:0; color:var(--fg);
    background:
      radial-gradient(1200px 800px at 15% -10%, #0f2b59 0%, transparent 55%),
      radial-gradient(1000px 700px at 110% 0%, #153160 0%, transparent 55%),
      linear-gradient(180deg,#0a1222 0%, #0b0f19 60%);
    font-family:Inter,system-ui,Segoe UI,Roboto,Arial }
  *{box-sizing:border-box}
  .wrap{max-width:var(--maxW); margin:0 auto; padding:18px}
  header{position:sticky; top:0; z-index:5; background:linear-gradient(180deg, rgba(5,10,22,.85), transparent); backdrop-filter:blur(10px)}
  .center{display:flex; justify-content:center}
  h1{margin:0; font-size:22px; letter-spacing:.2px}
  .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
  .btn{border:1px solid var(--border); background:linear-gradient(180deg,var(--panel),var(--panel2)); color:var(--fg); padding:10px 14px; border-radius:12px; cursor:pointer}
  .btn:hover{border-color:var(--accent); box-shadow:0 0 0 3px color-mix(in oklab,var(--accent) 20%, transparent)}
  .iconbtn{width:40px; height:40px; display:grid; place-items:center; border-radius:12px}
  input,select,textarea{ background:linear-gradient(180deg,var(--panel),var(--panel2)); border:1px solid var(--border); color:var(--fg); border-radius:12px; padding:10px 12px }
  .card{background:linear-gradient(180deg,var(--panel),var(--panel2)); border:1px solid var(--border); border-radius:var(--radius); padding:12px; box-shadow:0 10px 34px rgba(0,0,0,.22)}
  table{width:100%; border-collapse:separate; border-spacing:0 var(--gap)}
  thead th{font-size:13px; color:var(--muted); text-align:left; padding:0 12px}
  tbody td{padding:var(--padY) var(--padX); font-size:var(--font); background:linear-gradient(180deg,var(--panel),var(--panel2)); border:1px solid var(--border); border-left:none; border-right:none}
  tbody tr td:first-child{border-top-left-radius:var(--radius); border-bottom-left-radius:var(--radius); border-left:1px solid var(--border)}
  tbody tr td:last-child{border-top-right-radius:var(--radius); border-bottom-right-radius:var(--radius); border-right:1px solid var(--border)}
  .mono{font-variant-numeric:tabular-nums slashed-zero; font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
  .sym{font-weight:800}
  .pctPos{color:#22c55e; font-weight:800}
  #mgrBtn{position:fixed; right:22px; top:18px; z-index:50}
  #botBtn{position:fixed; right:72px; top:18px; z-index:50}
  .modal{position:fixed; inset:0; display:none; z-index:60}
  .modal.open{display:block}
  .overlay{position:absolute; inset:0; background:rgba(3,6,15,.55); backdrop-filter:blur(4px); opacity:0; animation:fadeIn .15s ease forwards}
  @keyframes fadeIn{to{opacity:1}}
  .panel{ position:absolute; right:24px; top:72px; width:min(560px, calc(100% - 32px)); background:linear-gradient(180deg,var(--panel),var(--panel2));
    border:1px solid var(--border); border-radius:18px; box-shadow:0 24px 80px rgba(0,0,0,.45); transform:translateY(-10px); opacity:0; animation:pop .18s ease forwards }
  @keyframes pop{to{transform:none; opacity:1}}
  .panel header{display:flex; align-items:center; justify-content:space-between; padding:14px 14px 0}
  .panel h3{margin:0; font-size:16px}
  .panel .content{padding:12px 14px 14px; display:grid; gap:12px}
  .grp{border:1px dashed var(--border); border-radius:14px; padding:10px}
  .lbl{font-size:12px; color:#9fb0c9; display:block; margin-bottom:6px}
  .chips{display:flex; flex-wrap:wrap; gap:8px}
  .chipx{background:var(--glass); border:1px solid var(--border); border-radius:999px; padding:6px 10px; display:inline-flex; gap:8px; align-items:center}
  .chipx button{all:unset; cursor:pointer; color:#9fb0c9; margin-left:8px}
  .status{display:inline-flex; gap:8px; align-items:center}
  .badge{font-size:12px; border:1px solid var(--border); padding:4px 8px; border-radius:999px; color:#9fb0c9; background:var(--glass)}
  .badge.wait{color:#f59e0b; border-color:#634f1a; background:rgba(245,158,11,.15)}
  .badge.lock{color:#60a5fa; border-color:#1b3b73; background:rgba(96,165,250,.15)}
  .badge.act{color:#22c55e; border-color:#1f5b36; background:rgba(34,197,94,.15)}
  .badge.block{color:#94a3b8; border-color:#334155; background:rgba(148,163,184,.15)}
  .btn-mini{border:1px solid var(--border); background:linear-gradient(180deg,var(--panel),var(--panel2)); color:var(--fg); padding:3px 8px; border-radius:8px; cursor:pointer; font-size:12px}
</style>
</head>
<body>
  <button id="botBtn" class="btn iconbtn" title="Bot"> ü§ñ </button>
  <button id="mgrBtn" class="btn iconbtn" title="Y√∂netim"> ‚öôÔ∏è </button>

  <header class="wrap center">
    <div class="row">
      <h1>Gate.io Futures ‚Üî Spot ‚Äî Maker Arb Bot</h1>
      <div class="chip">Saat: <span id="clock" class="mono">‚Äî:‚Äî:‚Äî</span></div>
    </div>
  </header>

  <main class="wrap center" style="padding-bottom:34px">
    <div class="card" style="width:100%">
      <table>
        <thead>
          <tr>
            <th>Coin</th>
            <th>Durum</th>
            <th>Spot ASK</th>
            <th>Fut BID</th>
            <th>% Short*</th>
            <th>Spot BID</th>
            <th>Fut ASK</th>
            <th>% Long*</th>
          </tr>
        </thead>
        <tbody id="tbody"></tbody>
      </table>
      <p id="emptyNote" style="margin:12px 6px 2px; color:#9fb0c9; font-size:13px; display:none">Liste bo≈ü.</p>
      <p style="margin:8px 6px 0; color:#9fb0c9; font-size:12px">* Yƒ±ldƒ±zlƒ± y√ºzdeler maker baz fiyatlarƒ±yla (a√ßƒ±lƒ±≈ü: Fut <b>ASK</b>, kapanƒ±≈ü: Fut <b>BID</b>) hesaplanƒ±r.</p>
    </div>
  </main>

  <!-- Y√∂netim -->
  <div id="mgrModal" class="modal">
    <div class="overlay" data-close="1"></div>
    <div class="panel">
      <header>
        <h3>Y√∂netim</h3>
        <button class="btn iconbtn" title="Kapat" data-close="1">‚úñ</button>
      </header>
      <div class="content">
        <div class="grp">
          <label class="lbl">Coin ekle/√ßƒ±kar (√∂rn: ETH ya da ETH_USDT)</label>
          <div class="row">
            <input id="addSym" type="text" placeholder="Sembol"/>
            <button id="btnAdd" class="btn">Ekle</button>
            <button id="btnClear" class="btn" style="margin-left:auto">T√ºm√ºn√º Sil</button>
          </div>
          <div id="chipWrap" class="chips" style="margin-top:8px"></div>
        </div>
        <div class="grp">
          <label class="lbl">Vurgu E≈üiƒüi (%)</label>
          <div class="row">
            <input id="thresh" type="number" step="0.01" value="0.10" style="width:140px"/>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- BOT -->
  <div id="botModal" class="modal">
    <div class="overlay" data-close="1"></div>
    <div class="panel">
      <header>
        <h3>Maker Arb Bot ‚Äî Ayarlar</h3>
        <button class="btn iconbtn" title="Kapat" data-close="1">‚úñ</button>
      </header>
      <div class="content">
        <div class="grp">
          <label class="lbl">√áalƒ±≈üma</label>
          <div class="row">
            <label class="row"><input type="checkbox" id="botEnable"/> Botu Ba≈ülat</label>
            <label class="row"><input type="checkbox" id="botDry" checked/> Dry-Run</label>
          </div>
        </div>
        <div class="grp">
          <label class="lbl">E≈üikler ve Tutar</label>
          <div class="row" style="gap:12px; flex-wrap:wrap">
            <label> A√ßƒ±≈ü (SHORT) % <input id="botOpenThresh" type="number" step="0.01" value="0.30" style="width:120px"/></label>
            <label> Kapanƒ±≈ü (LONG) % <input id="botCloseThresh" type="number" step="0.01" value="0.20" style="width:120px"/></label>
            <label> Hedef Notional (USDT) <input id="botNotional" type="number" step="1" value="10" style="width:140px"/></label>
            <label> Cooldown (ms) <input id="botCooldown" type="number" step="50" value="0" style="width:120px"/></label>
          </div>
        </div>
        <div class="grp">
          <label class="lbl">Futures</label>
          <div class="row" style="gap:12px; flex-wrap:wrap">
            <label> Kaldƒ±ra√ß <input id="botLev" type="number" step="1" value="5" style="width:100px"/></label>
            <label> Marjin
              <select id="botMargin" style="width:140px">
                <option value="isolated" selected>Isolated</option>
                <option value="cross">Cross</option>
              </select>
            </label>
          </div>
        </div>
        <div class="grp">
          <label class="lbl">API & Proxy</label>
          <div class="row" style="gap:12px; flex-wrap:wrap">
            <input id="spotKey" placeholder="Spot API KEY" style="flex:1 1 220px"/>
            <input id="spotSec" placeholder="Spot API SECRET" type="password" style="flex:1 1 220px"/>
          </div>
          <div class="row" style="gap:12px; flex-wrap:wrap; margin-top:8px">
            <input id="futKey" placeholder="Futures API KEY" style="flex:1 1 220px"/>
            <input id="futSec" placeholder="Futures API SECRET" type="password" style="flex:1 1 220px"/>
          </div>
          <div class="row" style="gap:12px; flex-wrap:wrap; margin-top:8px">
            <input id="proxyUrl" value="http://localhost:8787/" placeholder="Proxy URL (√∂rn: http://localhost:8787/ veya Cloudflare/Vercel)" style="flex:1 1 320px"/>
            <input id="proxyToken" placeholder="Proxy Token (opsiyonel)" style="flex:1 1 220px"/>
          </div>
          <div class="lbl">Not: Tarayƒ±cƒ±dan direkt REST CORS‚Äôa takƒ±lƒ±r; proxy zorunlu.</div>
        </div>
        <div class="grp">
          <label class="lbl">Log</label>
          <textarea id="botLog" class="mono" style="height:160px; resize:vertical" placeholder="Log..."></textarea>
        </div>
      </div>
    </div>
  </div>

<script>
/*** === Yardƒ±mcƒ±lar === ***/
const $=s=>document.querySelector(s), $$=s=>document.querySelectorAll(s);
const now=()=>new Date().toLocaleTimeString('tr-TR',{hour12:false});
const nf=new Intl.NumberFormat('tr-TR',{maximumFractionDigits:9});
const toNum=v=>typeof v==='number'?v:parseFloat(v);
const pctStr=v=>isFinite(v)?((v>=0?'+':'')+v.toFixed(3)+'%'):'‚Äî';
const sleep=ms=>new Promise(r=>setTimeout(r,ms));
const clamp=(x,a,b)=>Math.min(b,Math.max(a,x));
const fmtPx=p=>String(Number(p).toFixed(8));
function roundDown(x,d=6){const f=10**d;return Math.floor(x*f)/f;}

/*** === Durum === ***/
const S={
  coins:new Set(JSON.parse(localStorage.getItem('gate:list')||'["BTC_USDT","ETH_USDT"]')),
  ui:{thresh:+(localStorage.getItem('gate:thresh')||0.10)},
  ws:{spot:null,fut:null},
  spot:new Map(), fut:new Map(),
  rowEls:new Map(), rafScheduled:false,
  // bot state
  bot:{
    enabled:false, dry:true,
    openThresh:0.30, closeThresh:0.20, notional:10, cooldown:0,
    lev:5, margin:'isolated',
    spotKey:'',spotSec:'',futKey:'',futSec:'',
    proxy:'http://localhost:8787/', proxyToken:'',
    futSetup:new Set()
  },
  // per-symbol runtime
  state: new Map(), // sym -> {waiting:'open'|'close'|null, openOrderId, closeOrderId, lastCheckedTs, hedgedBase, lock:false}
  lastExecBySym:new Map()
};

function stGet(sym){ if(!S.state.has(sym)) S.state.set(sym,{waiting:null,openOrderId:null,closeOrderId:null,hedgedBase:0,lock:false}); return S.state.get(sym); }

/*** === UI === ***/
function botLog(t){ const ta=$('#botLog'); ta.value+=`[${now()}] ${t}\n`; ta.scrollTop=ta.scrollHeight; }
setInterval(()=>$('#clock').textContent=now(),1000);

$('#mgrBtn').onclick=()=>$('#mgrModal').classList.add('open');
$('#botBtn').onclick=()=>$('#botModal').classList.add('open');
$$('.modal').forEach(m=>m.addEventListener('click',e=>{ if(e.target.dataset.close) m.classList.remove('open'); }));

$('#thresh').value=String(S.ui.thresh||0.10);
$('#thresh').onchange=e=>{S.ui.thresh=+e.target.value; localStorage.setItem('gate:thresh',S.ui.thresh);};

$('#botEnable').onchange=e=>{S.bot.enabled=e.target.checked; botLog(S.bot.enabled?'Bot A√áIK':'Bot KAPALI');};
$('#botDry').onchange=e=>S.bot.dry=e.target.checked;
$('#botOpenThresh').onchange=e=>S.bot.openThresh=+e.target.value;
$('#botCloseThresh').onchange=e=>S.bot.closeThresh=+e.target.value;
$('#botNotional').onchange=e=>S.bot.notional=Math.max(5,+e.target.value||0);
$('#botCooldown').onchange=e=>S.bot.cooldown=Math.max(0,+e.target.value||0);
$('#botLev').onchange=e=>S.bot.lev=clamp(+e.target.value||1,1,125);
$('#botMargin').onchange=e=>S.bot.margin=e.target.value;
$('#spotKey').oninput=e=>S.bot.spotKey=e.target.value.trim();
$('#spotSec').oninput=e=>S.bot.spotSec=e.target.value.trim();
$('#futKey').oninput=e=>S.bot.futKey=e.target.value.trim();
$('#futSec').oninput=e=>S.bot.futSec=e.target.value.trim();
$('#proxyUrl').oninput=e=>S.bot.proxy=e.target.value.trim();
$('#proxyToken').oninput=e=>S.bot.proxyToken=e.target.value.trim();

function renderChips(){
  const wrap=$('#chipWrap'); wrap.innerHTML=''; const frag=document.createDocumentFragment();
  [...S.coins].forEach(sym=>{
    const c=document.createElement('div'); c.className='chipx'; c.textContent=sym.replace('_','');
    const x=document.createElement('button'); x.textContent='‚úï';
    x.onclick=()=>{ S.coins.delete(sym); localStorage.setItem('gate:list',JSON.stringify([...S.coins])); unsub(sym); const row=S.rowEls.get(sym); row?.tr.remove(); S.rowEls.delete(sym);};
    c.appendChild(x); frag.appendChild(c);
  }); wrap.appendChild(frag);
}
renderChips();
$('#btnAdd').onclick=()=>{
  const raw=$('#addSym').value.trim().toUpperCase(); if(!raw) return;
  let sym=raw.includes('_')?raw:raw.replace('USDT','_USDT'); sym=sym.replace(/[^A-Z0-9_]/g,''); if(!sym.endsWith('_USDT')) return alert('Sadece *_USDT');
  if(!S.coins.has(sym)){ S.coins.add(sym); localStorage.setItem('gate:list',JSON.stringify([...S.coins])); renderChips(); ensureRow(sym); sub(sym); }
  $('#addSym').value='';
};
$('#btnClear').onclick=()=>{
  if(!confirm('T√ºm coinleri sil?')) return;
  [...S.coins].forEach(unsub); S.coins.clear(); localStorage.setItem('gate:list','[]');
  S.rowEls.forEach(v=>v.tr.remove()); S.rowEls.clear();
};

/*** === WS === ***/
function wsConnect(kind){
  const url = kind==='spot' ? 'wss://api.gateio.ws/ws/v4/' : 'wss://fx-ws.gateio.ws/v4/ws/usdt';
  try{ S.ws[kind]?.close?.(); }catch{}
  const ws=new WebSocket(url); S.ws[kind]=ws;
  ws.onopen=()=>{ for(const sym of S.coins){ sendSub(kind,sym,true); } };
  ws.onmessage=(ev)=>{
    try{
      const j=JSON.parse(ev.data);
      if(!j||j.event!=='update'||!j.result) return;
      if(kind==='spot' && j.channel==='spot.book_ticker'){
        const r=j.result; const sym=r.s; const bid=toNum(r.b), ask=toNum(r.a);
        if(isFinite(bid)||isFinite(ask)) S.spot.set(sym,{bid,ask,ts:r.t||Date.now()});
      }
      if(kind!=='spot' && j.channel==='futures.book_ticker'){
        const r=j.result; const sym=r.s; const bid=toNum(r.b), ask=toNum(r.a);
        if(isFinite(bid)||isFinite(ask)) S.fut.set(sym,{bid,ask,ts:r.t||Date.now()});
      }
      scheduleDraw();
    }catch{}
  };
  ws.onclose=()=>setTimeout(()=>wsConnect(kind), 400+Math.random()*600);
  setInterval(()=>{ if(ws.readyState===1){ const t=Math.floor(Date.now()/1000); ws.send(JSON.stringify({time:t,channel:kind==='spot'?'spot.ping':'futures.ping'})); } },12000);
}
function sendSub(kind,sym,on){
  const ws=S.ws[kind]; if(!ws||ws.readyState!==1) return;
  const channel=kind==='spot'?'spot.book_ticker':'futures.book_ticker';
  ws.send(JSON.stringify({time:Math.floor(Date.now()/1000),channel,event:on?'subscribe':'unsubscribe',payload:[sym]}));
}
function sub(sym){ sendSub('spot',sym,true); sendSub('fut',sym,true); ensureRow(sym); }
function unsub(sym){ sendSub('spot',sym,false); sendSub('fut',sym,false); S.spot.delete(sym); S.fut.delete(sym); }

/*** === Tablo === ***/
function ensureRow(sym){
  if(S.rowEls.has(sym)) return;
  const tr=document.createElement('tr'); tr.dataset.sym=sym;
  const tdSym=document.createElement('td'); tdSym.className='sym'; tdSym.textContent=sym.replace('_','');

  const tdStatus=document.createElement('td'); tdStatus.className='status';
  const badge=document.createElement('span'); badge.className='badge'; badge.textContent='‚Äî';
  const btn=document.createElement('button'); btn.className='btn-mini'; btn.textContent='ƒ∞ptal'; btn.style.display='none';
  btn.onclick=()=>cancelWaiting(sym);
  tdStatus.append(badge,btn);

  const tdSAsk=document.createElement('td'); tdSAsk.className='mono'; const tdFBid=document.createElement('td'); tdFBid.className='mono';
  const tdShort=document.createElement('td'); tdShort.className='mono';
  const tdSBid=document.createElement('td'); tdSBid.className='mono'; const tdFAsk=document.createElement('td'); tdFAsk.className='mono';
  const tdLong=document.createElement('td'); tdLong.className='mono';

  tr.append(tdSym,tdStatus,tdSAsk,tdFBid,tdShort,tdSBid,tdFAsk,tdLong);
  $('#tbody').appendChild(tr);
  S.rowEls.set(sym,{tr,tdSAsk,tdFBid,tdShort,tdSBid,tdFAsk,tdLong,badge,btn});
}
function updateRow(sym,r){
  const el=S.rowEls.get(sym); if(!el) return;
  el.tdSAsk.textContent = isFinite(r.askS)?nf.format(r.askS):'‚Äî';
  el.tdFBid.textContent = isFinite(r.bidF)?nf.format(r.bidF):'‚Äî';
  el.tdSBid.textContent = isFinite(r.bidS)?nf.format(r.bidS):'‚Äî';
  el.tdFAsk.textContent = isFinite(r.askF)?nf.format(r.askF):'‚Äî';
  el.tdShort.innerHTML = isFinite(r.shortStar) ? `<span class="${r.shortStar>=S.ui.thresh?'pctPos':''}">${pctStr(r.shortStar)}</span>` : '‚Äî';
  el.tdLong.innerHTML  = isFinite(r.longStar)  ? `<span class="${r.longStar>=S.ui.thresh?'pctPos':''}">${pctStr(r.longStar)}</span>`  : '‚Äî';

  const st=stGet(sym);
  el.badge.className='badge'; el.badge.textContent='‚Äî'; el.btn.style.display='none';
  if(st.lock){ el.badge.classList.add('lock'); el.badge.textContent='‚öôÔ∏è ƒ∞≈ülem'; }
  else if(st.waiting==='open'){ el.badge.classList.add('wait'); el.badge.textContent='‚è≥ A√ßƒ±lƒ±≈ü'; el.btn.style.display=''; }
  else if(st.waiting==='close'){ el.badge.classList.add('act'); el.badge.textContent='‚è≥ Kapanƒ±≈ü'; el.btn.style.display=''; }
}

/*** === Hesaplama (maker baz fiyatlarƒ±yla) === ***/
function cmpFor(sym){
  const sp=S.spot.get(sym), fu=S.fut.get(sym); if(!sp||!fu) return null;
  const askS=sp.ask, bidS=sp.bid, bidF=fu.bid, askF=fu.ask;
  // maker bazlƒ± y√ºzdeler:
  const shortStar = isFinite(askS)&&isFinite(askF)&&askS>0 ? ((askF - askS)/askS*100) : NaN; // a√ßƒ±lƒ±≈ü (SELL futures at maker ask vs spot ask)
  const longStar  = isFinite(bidS)&&isFinite(bidF)&&bidF>0 ? ((bidS - bidF)/bidF*100) : NaN; // kapanƒ±≈ü (BUY futures at maker bid vs spot bid)
  return {sym, askS, bidS, bidF, askF, shortStar, longStar};
}

/*** === √áizim & Bot tetik === ***/
function scheduleDraw(){ if(!S.rafScheduled){ S.rafScheduled=true; requestAnimationFrame(draw); } }
async function draw(){
  S.rafScheduled=false;
  let any=false;
  for(const sym of S.coins){
    ensureRow(sym);
    const r=cmpFor(sym);
    if(r){ updateRow(sym,r); any=true; await maybeBot(sym,r); }
  }
  $('#emptyNote').style.display = any? 'none':'';
}

/*** === IPtal === ***/
function cancelWaiting(sym){
  const st=stGet(sym);
  if(st.waiting==='open' && st.openOrderId){ cancelFuturesOrder(sym, st.openOrderId).catch(()=>{}); }
  if(st.waiting==='close' && st.closeOrderId){ cancelFuturesOrder(sym, st.closeOrderId).catch(()=>{}); }
  st.waiting=null; st.openOrderId=null; st.closeOrderId=null;
  botLog(`üõë ${sym}: Bekleyen maker emri iptal edildi`);
}

/*** === Gate REST imza/fetch === ***/
const GATE={spotHost:'https://api.gateio.ws', futHost:'https://fx-api.gateio.ws', prefix:'/api/v4'};
async function sha512Hex(s){ const d=await crypto.subtle.digest('SHA-512', new TextEncoder().encode(s)); return [...new Uint8Array(d)].map(b=>b.toString(16).padStart(2,'0')).join(''); }
async function hmac512Hex(secret,msg){ const k=await crypto.subtle.importKey('raw',new TextEncoder().encode(secret),{name:'HMAC',hash:'SHA-512'},false,['sign']); const s=await crypto.subtle.sign('HMAC',k,new TextEncoder().encode(msg)); return [...new Uint8Array(s)].map(b=>b.toString(16).padStart(2,'0')).join(''); }
async function signHeaders(method,path,query,body,secret,key){
  const ts=Math.floor(Date.now()/1000).toString();
  const bodyHex=await sha512Hex(body||'');
  const signStr=`${method}\n${GATE.prefix}${path}\n${query||''}\n${bodyHex}\n${ts}`;
  const sign=await hmac512Hex(secret,signStr);
  return {'Content-Type':'application/json','Accept':'application/json','KEY':key,'Timestamp':ts,'SIGN':sign};
}
async function gateFetch(host,method,path,{query='',bodyObj=null,key='',secret='',proxy='',token=''}){
  const body=bodyObj?JSON.stringify(bodyObj):'';
  const headers=await signHeaders(method,path,query,body,secret,key);
  const url=host+GATE.prefix+path+(query?`?${query}`:'');
  const target=proxy?(proxy.endsWith('/')?proxy.slice(0,-1):proxy):null;
  if(target){
    const h={'Content-Type':'application/json'}; if(token) h['x-proxy-token']=token;
    const f=await fetch(target,{method:'POST',headers:h,body:JSON.stringify({url,method,headers,body})});
    if(!f.ok) throw new Error(`Proxy ${f.status}: ${await f.text()}`);
    return (f.headers.get('content-type')||'').includes('application/json')? f.json(): f.text();
  }else{
    const f=await fetch(url,{method,headers,body});
    if(!f.ok) throw new Error(`HTTP ${f.status}: ${await f.text()}`);
    return (f.headers.get('content-type')||'').includes('application/json')? f.json(): f.text();
  }
}

/*** === Meta & yardƒ±mcƒ± REST === ***/
const FutMeta=new Map(), SpotMeta=new Map();
function credsSpot(){return {key:S.bot.spotKey||S.bot.futKey, sec:S.bot.spotSec||S.bot.futSec};}
function credsFut(){ return {key:S.bot.futKey||S.bot.spotKey, sec:S.bot.futSec||S.bot.spotSec};}

async function getFutMeta(sym){
  if(FutMeta.has(sym)) return FutMeta.get(sym);
  const {key,sec}=credsFut();
  const m=await gateFetch(GATE.futHost,'GET',`/futures/usdt/contracts/${sym}`,{key,secret:sec,proxy:S.bot.proxy,token:S.bot.proxyToken});
  const meta={
    qm:Number(m.quanto_multiplier ?? m.multiplier ?? 1),
    step:Number(m.order_size_step ?? 1),
    min:Number(m.order_size_min ?? 1),
    max:Number(m.order_size_max ?? 1000000),
    tick: Number(m.order_price_round ?? m.tick_size ?? 0.01)
  };
  FutMeta.set(sym,meta); return meta;
}
async function ensureFutSettings(sym){
  const ck=`${sym}:${S.bot.margin}:${S.bot.lev}`; if(S.bot.futSetup.has(ck)) return;
  const {key,sec}=credsFut(); const proxy=S.bot.proxy, token=S.bot.proxyToken;
  const mode=S.bot.margin==='cross'?'cross':'isolated';
  try{ await gateFetch(GATE.futHost,'POST',`/futures/usdt/positions/margin_mode`,{bodyObj:{mode},key,secret:sec,proxy,token}); }catch{}
  try{ await gateFetch(GATE.futHost,'POST',`/futures/usdt/positions/${sym}/leverage`,{query:`leverage=${S.bot.lev}`,bodyObj:{},key,secret:sec,proxy,token}); }catch{}
  S.bot.futSetup.add(ck);
}
async function getFutOrder(sym,id){
  const {key,sec}=credsFut();
  return gateFetch(GATE.futHost,'GET',`/futures/usdt/orders/${id}`,{key,secret:sec,proxy:S.bot.proxy,token:S.bot.proxyToken});
}
async function cancelFuturesOrder(sym,id){
  const {key,sec}=credsFut();
  try{
    await gateFetch(GATE.futHost,'DELETE',`/futures/usdt/orders/${id}`,{key,secret:sec,proxy:S.bot.proxy,token:S.bot.proxyToken});
  }catch(e){ /* swallow */ }
}
async function getFutPosSize(sym){
  const {key,sec}=credsFut();
  try{
    const p=await gateFetch(GATE.futHost,'GET',`/futures/usdt/positions/${sym}`,{key,secret:sec,proxy:S.bot.proxy,token:S.bot.proxyToken});
    return Number(p.size||0); // short < 0
  }catch{ return 0; }
}
async function getSpotMeta(sym){
  if(SpotMeta.has(sym)) return SpotMeta.get(sym);
  const {key,sec}=credsSpot();
  const m=await gateFetch(GATE.spotHost,'GET',`/spot/currency_pairs/${sym}`,{key,secret:sec,proxy:S.bot.proxy,token:S.bot.proxyToken});
  const meta={
    amount_precision:Number(m.amount_precision ?? 6),
    min_base:Number(m.min_base_amount ?? 0),
    min_quote:Number(m.min_quote_amount ?? 0),
    base:(m.base||sym.split('_')[0]).toUpperCase()
  };
  SpotMeta.set(sym,meta); return meta;
}
async function getSpotAvail(base){
  const {key,sec}=credsSpot();
  const list=await gateFetch(GATE.spotHost,'GET',`/spot/accounts`,{query:`currency=${encodeURIComponent(base)}`,key,secret:sec,proxy:S.bot.proxy,token:S.bot.proxyToken});
  const rec=Array.isArray(list)?list.find(x=>(x.currency||'').toUpperCase()===base):null;
  return rec? Number(rec.available||0):0;
}

/*** === Emir Yerle≈ütirme === ***/
// Futures SELL maker (a√ßƒ±lƒ±≈ü): GTC, price = current top ASK (maker)
async function futMakerSellOpen(sym, usdtN){
  const {key,sec}=credsFut(); const meta=await getFutMeta(sym);
  const askF=S.fut.get(sym)?.ask; if(!(askF>0)) throw new Error('Fut ask yok');
  const nRaw = usdtN / (meta.qm * askF);
  let n = Math.max(meta.min, Math.min(Math.ceil(nRaw/meta.step)*meta.step, meta.max));
  n = Math.trunc(n); if(!(n>0)) n=meta.min;
  const body={contract:sym, size:-n, price:fmtPx(askF), tif:'gtc'};
  const res=await gateFetch(GATE.futHost,'POST',`/futures/usdt/orders`,{bodyObj:body,key,secret:sec,proxy:S.bot.proxy,token:S.bot.proxyToken});
  return { id:res?.id, price:askF, contracts:n, per:meta.qm };
}
// Futures BUY maker (kapanƒ±≈ü): GTC, price = current top BID (maker)
async function futMakerBuyClose(sym, contracts){
  const {key,sec}=credsFut(); const bidF=S.fut.get(sym)?.bid; if(!(bidF>0)) throw new Error('Fut bid yok');
  const body={contract:sym,size:Math.trunc(Math.max(1,contracts)),price:fmtPx(bidF),tif:'gtc',reduce_only:true};
  const res=await gateFetch(GATE.futHost,'POST',`/futures/usdt/orders`,{bodyObj:body,key,secret:sec,proxy:S.bot.proxy,token:S.bot.proxyToken});
  return { id:res?.id, price:bidF };
}
// Spot BUY taker (IOC) ‚Äî anlƒ±k hedge (a√ßƒ±lƒ±≈ü)
async function spotIOCbuyByNotional(sym, usdtN){
  const {key,sec}=credsSpot(); const meta=await getSpotMeta(sym);
  const askS=S.spot.get(sym)?.ask; if(!(askS>0)) throw new Error('Spot ask yok');
  let amt = roundDown(usdtN/askS, meta.amount_precision);
  if(meta.min_base && amt<meta.min_base) amt=meta.min_base;
  if(!(amt>0)) throw new Error('Spot amount yetersiz');
  const body={currency_pair:sym,type:'limit',account:'spot',side:'buy',amount:String(amt),price:fmtPx(askS),time_in_force:'ioc'};
  const res=await gateFetch(GATE.spotHost,'POST',`/spot/orders`,{bodyObj:body,key,secret:sec,proxy:S.bot.proxy,token:S.bot.proxyToken});
  return { id:res?.id, base:amt, px:askS, notional:amt*askS };
}
// Spot SELL taker (IOC) ‚Äî kapanƒ±≈üta hedge √ß√∂zme
async function spotIOCsellBase(sym, baseAmt){
  const {key,sec}=credsSpot(); const meta=await getSpotMeta(sym);
  const bidS=S.spot.get(sym)?.bid; if(!(bidS>0)) throw new Error('Spot bid yok');
  let amt = roundDown(baseAmt, meta.amount_precision);
  if(!(amt>0)) return {id:null, base:0, px:bidS, notional:0};
  const body={currency_pair:sym,type:'limit',account:'spot',side:'sell',amount:String(amt),price:fmtPx(bidS),time_in_force:'ioc'};
  const res=await gateFetch(GATE.spotHost,'POST',`/spot/orders`,{bodyObj:body,key,secret:sec,proxy:S.bot.proxy,token:S.bot.proxyToken});
  return { id:res?.id, base:amt, px:bidS, notional:amt*bidS };
}

/*** === Bot √ßekirdeƒüi === ***/
function lock(sym){ const st=stGet(sym); st.lock=true; }
function unlock(sym){ const st=stGet(sym); st.lock=false; }

async function maybeBot(sym, r){
  if(!S.bot.enabled) return;

  const st=stGet(sym);
  // a√ßƒ±k poz var mƒ±? (hedgedBase>0 veya futures short size<0)
  const hasActive = st.hedgedBase>0.0000001 || (await getFutPosSize(sym))<0;

  // KAPANI≈û ko≈üulu: maker LONG farkƒ±
  if(hasActive && isFinite(r.longStar) && r.longStar>=S.bot.closeThresh && !st.lock){
    st.waiting='close'; updateRow(sym,r);
    await doCloseCycle(sym); return;
  }

  // A√áILI≈û ko≈üulu: maker SHORT farkƒ±
  if(!hasActive && isFinite(r.shortStar) && r.shortStar>=S.bot.openThresh && !st.lock){
    st.waiting='open'; updateRow(sym,r);
    await doOpenCycle(sym); return;
  }

  // aksi halde bekleme yoksa rozeti reset
  if(!hasActive && !st.openOrderId && !st.closeOrderId && st.waiting===null){
    updateRow(sym,r);
  }
}

/*** === A√ßƒ±lƒ±≈ü D√∂ng√ºs√º: maker SELL -> kƒ±smi fill‚Äôlerde spot IOC BUY === ***/
async function doOpenCycle(sym){
  const st=stGet(sym);
  if(S.bot.dry){ botLog(`(dry) ${sym} a√ßƒ±lƒ±≈ü d√∂ng√ºs√º`); st.waiting=null; return; }

  lock(sym);
  try{
    await ensureFutSettings(sym);

    // Emri ilk ask‚Äôa koy
    const {id,price,contracts,per}=await futMakerSellOpen(sym,S.bot.notional);
    st.openOrderId=id; st.lastCheckedTs=0;
    botLog(`‚ñ∂ ${sym} OPEN fut SELL GTC @${fmtPx(price)} (n=${contracts})`);

    let prevLeft=null, done=false;
    while(st.waiting==='open' && st.openOrderId && !done){
      // hƒ±z
      if(S.bot.cooldown>0) await sleep(S.bot.cooldown); else await sleep(250);

      // FARK uygunsuzla≈ütƒ± mƒ±?
      const r=cmpFor(sym);
      if(!(r && isFinite(r.shortStar) && r.shortStar>=S.bot.openThresh)){
        botLog(`‚Ü© ${sym} fark yetersiz ‚Üí OPEN maker iptal`);
        await cancelFuturesOrder(sym, st.openOrderId); st.openOrderId=null; st.waiting=null; break;
      }

      // Top ask deƒüi≈ümi≈üse ‚Üí iptal & yeniden en √ºste koy
      const curAsk=S.fut.get(sym)?.ask||0;
      if(curAsk>0 && Math.abs(curAsk - price) > 1e-8){
        await cancelFuturesOrder(sym, st.openOrderId); st.openOrderId=null;
        const rep=await futMakerSellOpen(sym,S.bot.notional);
        st.openOrderId=rep.id; botLog(`‚ü≥ ${sym} OPEN reprice SELL @${fmtPx(rep.price)}`);
      }

      // Fill kontrol√º
      const ord=await getFutOrder(sym, st.openOrderId);
      const left=Number(ord.left??ord.remain??ord.unfilled??contracts);
      const size=Number(ord.size??contracts);
      if(prevLeft===null) prevLeft=left;
      const filled = Math.max(0, (prevLeft - left));
      prevLeft=left;
      if(filled>0){
        // notional ‚âà filled * per * limitPrice (yakla≈üƒ±k)
        const notional = filled * per * (S.fut.get(sym)?.ask||price);
        try{
          const spot=await spotIOCbuyByNotional(sym, notional);
          st.hedgedBase += spot.base;
          botLog(`‚úÖ ${sym} HEDGE spot BUY base‚âà${spot.base.toFixed(6)} @${fmtPx(spot.px)} (N‚âà${spot.notional.toFixed(4)})`);
        }catch(e){
          botLog(`‚ùå ${sym} spot BUY hedge hata: ${e?.message||e}`);
        }
      }
      if(left<=0){ done=true; botLog(`‚úî ${sym} OPEN futures SELL tamamlandƒ±`); st.waiting=null; }
    }
  }catch(e){
    botLog(`üí• ${sym} OPEN hata: ${e?.message||e}`);
    if(st.openOrderId){ await cancelFuturesOrder(sym, st.openOrderId).catch(()=>{}); st.openOrderId=null; }
    st.waiting=null;
  }finally{ unlock(sym); updateRow(sym, cmpFor(sym) || {}); }
}

/*** === Kapanƒ±≈ü D√∂ng√ºs√º: maker BUY -> kƒ±smi fill‚Äôlerde spot IOC SELL === ***/
async function doCloseCycle(sym){
  const st=stGet(sym);
  if(S.bot.dry){ botLog(`(dry) ${sym} kapanƒ±≈ü d√∂ng√ºs√º`); st.waiting=null; return; }

  lock(sym);
  try{
    const posSz=await getFutPosSize(sym); // short negatif
    const shortOpen = posSz<0 ? -Math.trunc(Math.abs(posSz)) : 0;
    if(shortOpen===0 && st.hedgedBase<=0){
      botLog(`‚Ñπ ${sym} kapatƒ±lacak poz yok`); st.waiting=null; return;
    }
    // Eƒüer kontrat 0 ama hedge base varsa, sadece spot sat d√∂ng√ºs√º yapacaƒüƒ±z
    let buyId=null, prevLeft=null;
    if(shortOpen>0){
      const rep=await futMakerBuyClose(sym, shortOpen);
      buyId=rep.id; botLog(`‚ñ∂ ${sym} CLOSE fut BUY GTC @${fmtPx(rep.price)} (target=${shortOpen})`);
      st.closeOrderId=buyId;
    }

    let done=false;
    while(st.waiting==='close' && !done){
      if(S.bot.cooldown>0) await sleep(S.bot.cooldown); else await sleep(250);

      // Fark (LONG) uygunsuzsa ‚Üí iptal
      const r=cmpFor(sym);
      if(!(r && isFinite(r.longStar) && r.longStar>=S.bot.closeThresh)){
        if(buyId){ await cancelFuturesOrder(sym,buyId).catch(()=>{}); st.closeOrderId=null; }
        botLog(`‚Ü© ${sym} fark yetersiz ‚Üí CLOSE maker iptal`);
        st.waiting=null; break;
      }

      // Reprice gerekiyorsa (top bid deƒüi≈üti)
      const curBid=S.fut.get(sym)?.bid||0;
      if(buyId && curBid>0){
        const ord=await getFutOrder(sym,buyId);
        const pricePlaced=Number(ord.price||curBid);
        if(Math.abs(curBid - pricePlaced)>1e-8){
          await cancelFuturesOrder(sym,buyId).catch(()=>{});
          const posSzNow=await getFutPosSize(sym);
          const stillShort = posSzNow<0 ? -Math.trunc(Math.abs(posSzNow)) : 0;
          if(stillShort>0){
            const rep=await futMakerBuyClose(sym, stillShort);
            buyId=rep.id; st.closeOrderId=buyId;
            botLog(`‚ü≥ ${sym} CLOSE reprice BUY @${fmtPx(rep.price)} (remain=${stillShort})`);
            prevLeft=null;
          }else buyId=null;
        }
      }

      // Fill kontrol√º + spot satƒ±≈ü
      if(buyId){
        const ord=await getFutOrder(sym,buyId);
        const left=Number(ord.left??ord.remain??0);
        const size=Number(ord.size??0);
        if(prevLeft===null) prevLeft=left;
        const filled = Math.max(0,(prevLeft-left));
        prevLeft=left;
        if(filled>0){
          const per=(await getFutMeta(sym)).qm;
          const baseToSellApprox = filled * per; // hedge bazƒ±nƒ± azalt
          const sellBase = Math.min(st.hedgedBase, baseToSellApprox);
          try{
            const spot=await spotIOCsellBase(sym, sellBase);
            st.hedgedBase = Math.max(0, st.hedgedBase - sellBase);
            botLog(`‚úÖ ${sym} HEDGE spot SELL base‚âà${spot.base.toFixed(6)} @${fmtPx(spot.px)} (N‚âà${spot.notional.toFixed(4)})`);
          }catch(e){ botLog(`‚ùå ${sym} spot SELL hedge hata: ${e?.message||e}`); }
        }
        if(left<=0){
          // futures kapandƒ±; kalan b√ºt√ºn hedge‚Äôi sat
          if(st.hedgedBase>0){
            try{
              const spot=await spotIOCsellBase(sym, st.hedgedBase);
              st.hedgedBase=0; botLog(`‚úÖ ${sym} Kalan hedge tamamƒ± satƒ±ldƒ±: base‚âà${spot.base.toFixed(6)}`);
            }catch(e){ botLog(`‚ùå ${sym} kalan hedge satƒ±≈ü hata: ${e?.message||e}`); }
          }
          botLog(`‚úî ${sym} CLOSE tamamlandƒ±`);
          st.waiting=null; st.closeOrderId=null; done=true; break;
        }
      }else{
        // Sadece hedge varsa satmaya devam et
        if(st.hedgedBase>0){
          try{
            const spot=await spotIOCsellBase(sym, st.hedgedBase);
            st.hedgedBase=0; botLog(`‚úÖ ${sym} hedge-only SELL: base‚âà${spot.base.toFixed(6)}`);
          }catch(e){ botLog(`‚ùå ${sym} hedge-only SELL hata: ${e?.message||e}`); }
        }
        botLog(`‚úî ${sym} CLOSE (futures yok) tamam`);
        st.waiting=null; done=true; break;
      }
    }
  }catch(e){
    botLog(`üí• ${sym} CLOSE hata: ${e?.message||e}`);
    const st2=stGet(sym);
    if(st2.closeOrderId){ await cancelFuturesOrder(sym, st2.closeOrderId).catch(()=>{}); st2.closeOrderId=null; }
    st2.waiting=null;
  }finally{ unlock(sym); updateRow(sym, cmpFor(sym) || {}); }
}

/*** === Ba≈ülat === ***/
function start(){
  S.coins.forEach(ensureRow);
  wsConnect('spot'); wsConnect('fut'); S.coins.forEach(sub);
  scheduleDraw();
}
start();
</script>
</body>
</html>
